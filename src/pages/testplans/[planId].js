import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import table from '../../styles/Table.module.css';
import form from '../../styles/Form.module.css';
import Header from '../../components/Header';
import Select from 'react-select';

function TestPlanDetails() {
    const [testSteps, setTestSteps] = useState([]);
    const [description, setDescription] = useState('');
    const [order, setOrder] = useState('');
    const router = useRouter();
    const { planId } = router.query;
    const [tagOptions, setTagOptions] = useState([]);
    const [selectedTags, setSelectedTags] = useState([]);

    useEffect(() => {
        fetch('/api/tags')
            .then(response => response.json())
            .then(data => {
                const options = data.map(tag => ({ value: tag.id, label: tag.name }));
                setTagOptions(options);
            })
            .catch(error => console.error('Failed to fetch tags:', error));
    }, []);

    useEffect(() => {
        if (planId) {
            fetch(`/api/testplansteps?id=${planId}`, {
                credentials: 'include'
            })
                .then(response => response.json())
                .then(data => {
                    const sortedData = data.sort((a, b) => a.step_order - b.step_order);
                    setTestSteps(sortedData);
                    const maxOrder = sortedData.reduce((max, step) => Math.max(max, step.step_order), 0);
                    setOrder(maxOrder + 1);
                })
                .catch(error => console.error('Failed to load test steps:', error));
            fetch(`/api/testplans/${planId}/tags`, {
                credentials: 'include'
            })
                .then(response => response.json())
                .then(data => {
                    const formattedTags = data.map(tag => ({
                        value: tag.id,
                        label: tag.name
                    }));
                    setSelectedTags(formattedTags);            })
                .catch(error => console.error('Failed to fetch selected tags:', error));
        }
    }, [planId]);

    const handleAddStep = async (event) => {
        event.preventDefault();
        const currentOrder = order;
        try {
            const response = await fetch('/api/testplansteps', {
                method: 'POST',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ planId, description, order: currentOrder })
            });
            const newStep = await response.json();
            if (response.ok) {
                setTestSteps([...testSteps, {...newStep, step_order: currentOrder}]);
                setDescription('');
                setOrder(parseInt(currentOrder) + 1);
            } else {
                throw new Error('Failed to create test step');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('Failed to add test step');
        }
    };

    const onDragEnd = (result) => {
        const { destination, source } = result;
        if (!destination || destination.index === source.index) {
            return;
        }

        const newSteps = Array.from(testSteps);
        const movedItem = newSteps.splice(source.index, 1)[0];
        newSteps.splice(destination.index, 0, movedItem);

        const updatedSteps = newSteps.map((step, index) => ({
            ...step,
            step_order: index + 1
        }));

        setTestSteps(updatedSteps);
        updateStepOrderOnServer(updatedSteps);
    };

    const updateStepOrderOnServer = async (newOrder) => {
        try {
            const payload = newOrder.map(step => ({
                id: step.id,
                step_order: step.step_order
            }));

            const response = await fetch(`/api/testplansteps/${planId}/order`, {
                method: 'PATCH',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ step_order: payload })
            });
            if (!response.ok) {
                throw new Error('Failed to update step order');
            }
            const result = await response.json();
            console.log('Updated steps:', result);
        } catch (error) {
            console.error('Error updating step order:', error);
        }
    };
    const handleStatusClick = async (stepId) => {
        const updatedSteps = testSteps.map(step => {
            if (step.id === stepId) {
                const newStatus = cycleStatus(step.status);
                return { ...step, status: newStatus };
            }
            return step;
        });
        setTestSteps(updatedSteps);
        const updatedStep = updatedSteps.find(step => step.id === stepId);
        try {
            const response = await fetch(`/api/testplansteps/${stepId}/state`, {
                method: 'PATCH',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ state: updatedStep.status })
            });
            if (!response.ok) {
                throw new Error('Failed to update step status');
            }
            const result = await response.json();
        } catch (error) {
            console.error('Error updating step status:', error);
            setTestSteps(testSteps);
        }
    };

    const cycleStatus = currentStatus => {
        const statuses = ['active', 'removed', 'deprecated'];
        const currentIndex = statuses.indexOf(currentStatus);
        const nextIndex = (currentIndex + 1) % statuses.length;
        return statuses[nextIndex];
    };

    const handleUpdateTags = async () => {
        try {
            console.log(selectedTags);
            const response = await fetch(`/api/testplans/${planId}/tags`, {
                method: 'PATCH',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ tags: selectedTags })
            });
            if (response.ok) {
                console.log('Tags updated successfully');
            } else {
                throw new Error('Failed to update tags');
            }
        } catch (error) {
            console.error('Failed to update tags:', error);
        }
    };

    return (
        <div>
            <Header/>
            <h1>Details for Test Plan ID: {planId}</h1>
            <div className="flex-container">
                <Select
                    isMulti
                    name="tags"
                    options={tagOptions}
                    className="basic-multi-select"
                    classNamePrefix="select"
                    value={selectedTags}
                    onChange={setSelectedTags}
                    placeholder="Select Tags"
                    styles={{
                        control: (provided) => ({
                            ...provided,
                            width: 600
                        }),
                        option: (provided) => ({
                            ...provided,
                            color: 'grey'
                        })
                    }}
                />
                <button onClick={handleUpdateTags} className={form.button}>Update Tags</button>
            </div>
            <div>
                <h2>Create new test step:</h2>
            </div>
            <form onSubmit={handleAddStep}>
                <input
                    type="text"
                    value={description}
                    onChange={e => setDescription(e.target.value)}
                    placeholder="Step Description"
                    className={form.input}
                    style={{ color: 'grey' }}
                    required
                />
                <button className={form.button} type="submit">Add Test Step</button>
            </form>
            <DragDropContext onDragEnd={onDragEnd}>
                <Droppable droppableId="stepsDroppable">
                    {(provided) => (
                        <table className={table.table} {...provided.droppableProps} ref={provided.innerRef}>
                            <thead>
                                <tr>
                                    <th className={table.th}>Step Order</th>
                                    <th className={table.th}>Description</th>
                                    <th className={table.th}>Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                {testSteps.map((step, index) => (
                                    <Draggable key={step.id} draggableId={step.id.toString()} index={index}>
                                        {(provided) => (
                                            <tr ref={provided.innerRef} {...provided.draggableProps} {...provided.dragHandleProps}>
                                                <td className={table.td}>{step.step_order}</td>
                                                <td className={table.td}>{step.description}</td>
                                                <td className={table.td} onClick={() => handleStatusClick(step.id)}
                                                    style={{ cursor: 'pointer', color: '#0077ff' }}>
                                                    {step.status}
                                                </td>
                                            </tr>
                                        )}
                                    </Draggable>
                                ))}
                                {provided.placeholder}
                            </tbody>
                        </table>
                    )}
                </Droppable>
            </DragDropContext>

        </div>
    );


}

export default TestPlanDetails;
