import { createRouter } from 'next-connect';
import pool from '../../../lib/db';

const router = createRouter();

router
    .get(async (req, res) => {
        try {
            const query = `
            SELECT tr.id, tr.name, tr.version, tr.target_url, tr.created_at, 
                COUNT(trs.id) AS total_steps,
                COUNT(trs.id) FILTER (WHERE trs.status = 'complete') AS completed_steps,
                COALESCE(COUNT(trs.id) FILTER (WHERE trs.status = 'complete') * 1.0 / NULLIF(COUNT(trs.id), 0), 0) AS progress
            FROM test_runs tr
            LEFT JOIN test_run_steps trs ON tr.id = trs.test_run_id
            WHERE tr.state = 'active'
            GROUP BY tr.id
            ORDER BY tr.created_at DESC;
        `;
            const result = await pool.query(query);
            res.json(result.rows);
        } catch (err) {
            console.error(err.stack);
            res.status(500).json({ error: 'Failed to fetch data' });
        }
    })

    .post(async (req, res) => {
        const { name, version, tags, target_url } = req.body;
        const user_ids = req.body.user_ids;
        if (!name || !version || !tags || !target_url) {
            return res.status(400).json({ error: 'Missing fields' });
        }
        if (!user_ids) {
            return res.status(400).json({ error: 'Invalid users, at least one user is required' });
        }
        const client = await pool.connect();
        try {
            await client.query('BEGIN');

            const runResult = await client.query('INSERT INTO test_runs (name, version, target_url) VALUES ($1, $2, $3) RETURNING *', [name, version, target_url, ]);
            const testRun = runResult.rows[0];
            const testPlanResults = [];
            for (let tag of tags) {
                const result = await client.query(
                    `SELECT test_plan_id FROM test_plan_tags WHERE tag_id = $1`,
                    [tag.value]
                );
                if (result.rows.length > 0) {
                    for (let row of result.rows) {
                        testPlanResults.push(row);
                    }
                }
            }
            for (let plan of testPlanResults) {
                const stepsResult = await client.query('SELECT * FROM test_steps WHERE plan_id = $1 and status = \'active\'', [plan.test_plan_id]);
                for (let step of stepsResult.rows) {
                    for (let id of user_ids) {
                        await client.query('INSERT INTO test_run_steps (test_run_id, test_plan_id, test_step_id, status, user_id) VALUES ($1, $2, $3, $4, $5)',
                            [testRun.id, plan.test_plan_id, step.id, 'pending', id]);
                    }
                }
            }

            await client.query('COMMIT');
            res.status(201).json(testRun);
        } catch (err) {
            await client.query('ROLLBACK');
            console.error(err.stack);
            res.status(500).json({ error: 'Failed to create test run' });
        } finally {
            client.release();
        }
    });

export default router.handler({
    onError: (err, req, res) => {
        console.error(err.stack);
        res.status(500).json({ error: 'Something went wrong!' });
    },
    onNoMatch: (req, res) => {
        res.status(404).json({ error: 'Not Found' });
    }
});
