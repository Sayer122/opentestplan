import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import Link from 'next/link';
import Header from '../../components/Header';
import table from '../../styles/Table.module.css';
import header from '../../styles/Header.module.css';
import ProgressBar from '../../components/ProgressBar';
import 'bootstrap-icons/font/bootstrap-icons.css';

function TestPlanDetails() {
    const router = useRouter();
    const { runId } = router.query;

    const [runDetails, setRunDetails] = useState({});
    const [groupedStepsByUser, setGroupedStepsByUser] = useState({});
    const [collapsedUsers, setCollapsedUsers] = useState({});
    const [collapsedPlans, setCollapsedPlans] = useState({});
    const [passedProgress, setPassedProgress] = useState(0);
    const [failedProgress, setFailedProgress] = useState(0);
    const [userProgress, setUserProgress] = useState({});

    useEffect(() => {
        if (runId) {
            fetch(`/api/testruns/${runId}/users`, {
                credentials: 'include'
            })
                .then(response => response.json())
                .then(users => {
                    const usersObj = users.reduce((acc, user) => ({
                        ...acc,
                        [user.user_id]: { username: user.username, collapsed: true, plans: {} }
                    }), {});
                    setCollapsedUsers(usersObj);

                    fetch(`/api/testruns/${runId}`, {
                        credentials: 'include'
                    })
                        .then(response => response.json())
                        .then(steps => {
                            const usersSteps = steps.reduce((acc, step) => {
                                const { user_id, test_plan_name, test_step_name, step_order, ...rest } = step;
                                if (!acc[user_id].plans[test_plan_name]) acc[user_id].plans[test_plan_name] = [];
                                acc[user_id].plans[test_plan_name].push({ step_order, description: test_step_name, ...rest });
                                acc[user_id].plans[test_plan_name].sort((a, b) => a.step_order - b.step_order);
                                return acc;
                            }, {...usersObj});
                            setGroupedStepsByUser(usersSteps);
                        });

                    fetch(`/api/testruns/${runId}/details`, {
                        credentials: 'include'
                    })
                        .then(response => response.json())
                        .then(data => {
                            setRunDetails(data[0]);
                        })
                        .catch(error => console.error('Failed to load test run details:', error));
                });
        }
    }, [runId]);


    const updateStatus = async (userId, planName, stepIndex, stepId) => {
        const userPlans = groupedStepsByUser[userId]?.plans;
        const steps = userPlans?.[planName];
        if (!steps || steps.length <= stepIndex) {
            console.error('Invalid step index or plan name');
            return;
        }

        const currentStatus = steps[stepIndex].status;
        let newStatus;
        switch (currentStatus) {
        case 'complete':
            newStatus = 'failed';
            break;
        case 'pending':
            newStatus = 'complete';
            break;
        case 'failed':
            newStatus = 'pending';
            break;
        default:
            newStatus = 'complete';
        }

        try {
            const response = await fetch(`/api/testruns/${runId}/status`, {
                method: 'PATCH',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ id: stepId, state: newStatus })
            });
            if (response.ok) {
                const updatedSteps = [...steps];
                updatedSteps[stepIndex].status = newStatus;
                setGroupedStepsByUser(prev => ({
                    ...prev,
                    [userId]: {
                        ...prev[userId],
                        plans: {
                            ...prev[userId].plans,
                            [planName]: updatedSteps
                        }
                    }
                }));
            }
        } catch (error) {
            console.error('Failed to update status:', error);
        }
    };



    const updateComment = async (userId, planName, stepIndex, stepId, comment) => {
        try {
            const response = await fetch(`/api/testruns/${runId}/comments`, {
                method: 'PATCH',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ id: stepId, comment })
            });
            if (response.ok) {
                const steps = groupedStepsByUser[userId]?.plans[planName];
                const updatedSteps = [...steps];
                updatedSteps[stepIndex].comments = comment;
                setGroupedStepsByUser(prev => ({
                    ...prev,
                    [userId]: {
                        ...prev[userId],
                        plans: {
                            ...prev[userId].plans,
                            [planName]: updatedSteps
                        }
                    }
                }));
                console.log('Comment updated successfully');
            }
        } catch (error) {
            console.error('Failed to update comment:', error);
        }
    };

    const handleCommentChange = (e, userId, planName, stepIndex) => {
        const steps = groupedStepsByUser[userId]?.plans[planName];
        if (steps && steps.length > stepIndex) {
            const updatedSteps = [...steps];
            updatedSteps[stepIndex].comments = e.target.value;

            setGroupedStepsByUser(prev => ({
                ...prev,
                [userId]: {
                    ...prev[userId],
                    plans: {
                        ...prev[userId].plans,
                        [planName]: updatedSteps
                    }
                }
            }));
        }
    };

    const handleCommentUpdate = (userId, planName, stepIndex) => {
        const steps = groupedStepsByUser[userId]?.plans[planName];
        if (steps && steps.length > stepIndex) {
            const comment = steps[stepIndex].comments;
            const stepId = steps[stepIndex].id;

            updateComment(userId, planName, stepIndex, stepId, comment);
        }
    };

    useEffect(() => {
        if (runId) {
            fetch(`/api/testruns/${runId}/progress`, {
                credentials: 'include'
            })
                .then(response => response.json())
                .then(data => {
                    setPassedProgress(data.overall.passedProgress);
                    setFailedProgress(data.overall.failedProgress);
                    setUserProgress(data.byUser);
                });
        }
    }, [runId, groupedStepsByUser]);

    function handleTicketNumberChange(event, userId, planName, stepIndex) {
        const newTicketNumber = event.target.value;
        if (newTicketNumber.length <= 6) {
            const steps = groupedStepsByUser[userId]?.plans[planName];
            if (steps && steps.length > stepIndex) {
                const updatedSteps = [...steps];
                updatedSteps[stepIndex].ticket = newTicketNumber;

                setGroupedStepsByUser(prev => ({
                    ...prev,
                    [userId]: {
                        ...prev[userId],
                        plans: {
                            ...prev[userId].plans,
                            [planName]: updatedSteps
                        }
                    }
                }));
            }
        }
    }

    const handleTicketUpdate = async (userId, planName, stepIndex, stepId) => {
        const ticketNumber = groupedStepsByUser[userId]?.plans[planName][stepIndex].ticket;
        try {
            const response = await fetch(`/api/testruns/${runId}/ticket`, {
                method: 'PATCH',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ ticketNumber, stepId })
            });
            if (response.ok) {
                const steps = groupedStepsByUser[userId]?.plans[planName];
                const updatedSteps = [...steps];
                updatedSteps[stepIndex].ticket = ticketNumber;
                setGroupedStepsByUser(prev => ({
                    ...prev,
                    [userId]: {
                        ...prev[userId],
                        plans: {
                            ...prev[userId].plans,
                            [planName]: updatedSteps
                        }
                    }
                }));
            }
        } catch (error) {
            console.error('Failed to update ticket number:', error);
        }
    };

    const toggleUser = (userId) => {
        setCollapsedUsers(prev => ({ ...prev, [userId]: !prev[userId] }));
    };

    const togglePlan = (userId, planName) => {
        setCollapsedPlans(prev => ({
            ...prev,
            [userId]: {
                ...prev[userId],
                [planName]: !(prev[userId] && prev[userId][planName])
            }
        }));
    };
    const completeAllSteps = async (userId, planName) => {
        const steps = groupedStepsByUser[userId].plans[planName];
        for (let i = 0; i < steps.length; i++) {
            const step = steps[i];
            if (step.status !== 'complete') {
                await updateStatus(userId, planName, i, step.id);
            }
        }
    };

    return (
        <>
            <Header />
            <div style={{ marginLeft: '20px', marginRight: '20px' }}>
                <ProgressBar
                    progress={passedProgress}
                    failed={failedProgress}
                />
                <div className={header.detailsHeader} style={{ marginTop: '20px' }}>
                    <div>
                        <h1>{runDetails.name}</h1>
                        <h2>Version: {runDetails.version}</h2>
                        <h2>Target URL: <a href={runDetails.target_url} target="_blank" rel="noopener noreferrer">{runDetails.target_url}</a></h2>
                    </div>
                    <h3>Created on: {new Date(runDetails.created_at).toLocaleDateString()} at {new Date(runDetails.created_at).toLocaleTimeString()}</h3>
                </div>
                {Object.keys(groupedStepsByUser).map(userId => (
                    <div key={userId}>
                        <h1 onClick={() => toggleUser(userId)} style={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-start' }}>
                            <span style={{ width: '200px', fontSize: '24px' }}>{groupedStepsByUser[userId].username}</span>
                            <i className={`bi ${collapsedUsers[userId] ? 'bi-chevron-right' : 'bi-chevron-down'}`} style={{ marginLeft: '30px', marginRight:'50px' }}></i>
                            {userProgress[userId] && (
                                <ProgressBar
                                    progress={userProgress[userId].passedProgress}
                                    failed={userProgress[userId].failedProgress}
                                />
                            )}
                        </h1>

                        {!collapsedUsers[userId] && Object.keys(groupedStepsByUser[userId].plans).map(planName => (
                            <div key={planName}>
                                <h1 onClick={() => togglePlan(userId, planName)}>
                                    {planName} {collapsedPlans[userId] && collapsedPlans[userId][planName] ? <i className="bi bi-chevron-right"></i> : <i className="bi bi-chevron-down"></i>}
                                </h1>
                                {!(collapsedPlans[userId] && collapsedPlans[userId][planName]) && (
                                    <table className={table.table}>
                                        <thead>
                                            <tr>
                                                <th className={table.th}>Step</th>
                                                <th className={table.th}>Details</th>
                                                <th className={table.th}>Comments</th>
                                                <th className={table.th}>Status</th>
                                                <th className={table.th}>Ticket</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {groupedStepsByUser[userId].plans[planName].map((step, index) => (
                                                <tr key={index}>
                                                    <td className={table.td}>{step.step_order}</td>
                                                    <td className={table.td}>{step.description}</td>
                                                    <td className={table.td}>
                                                        <textarea style={{color: '#333'}} className="form-control" value={step.comments || ''} onChange={e => handleCommentChange(e, userId, planName, index, step.id)} onBlur={() => handleCommentUpdate(userId, planName, index, step.id)} />
                                                    </td>
                                                    <td className={table.td} onClick={() => updateStatus(userId, planName, index, step.id)}>
                                                        {step.status === 'complete' ?
                                                            <i className="bi bi-check-circle-fill" style={{ color: '#2e8f39' }}></i> :
                                                            step.status === 'pending' ?
                                                                <i className="bi bi-dash-circle-fill" style={{ color: 'grey' }}></i> :
                                                                step.status === 'failed' ?
                                                                    <i className="bi bi-x-circle-fill" style={{ color: '#bf2b1f' }}></i> :
                                                                    'Click to set status'}
                                                    </td>
                                                    <td className={table.td}>
                                                        <input type="number" style={{color: '#333'}} className="form-control" value={step.ticket || ''} onChange={e => handleTicketNumberChange(e, userId, planName, index, step.id)} onBlur={() => handleTicketUpdate(userId, planName, index, step.id)} placeholder="Ticket number" />
                                                    </td>
                                                </tr>
                                            ))}
                                            <tr>
                                                <td colSpan="5" className={table.td} style={{ textAlign: 'center' }}>
                                                    <button onClick={() => completeAllSteps(userId, planName)} className="btn btn-success" style={{ width: 'auto', padding: '8px 16px' }}>
                                                Complete All
                                                        <i className="bi bi-check-circle-fill" style={{ marginLeft: '8px', color: '#2e8f39' }}></i>
                                                    </button>
                                                </td>

                                            </tr>
                                        </tbody>
                                    </table>
                                )}
                            </div>
                        ))}
                    </div>
                ))}

            </div>
        </>
    );
}

export default TestPlanDetails;
